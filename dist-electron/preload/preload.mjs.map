{"version":3,"file":"preload.mjs","sources":["../../electron/handlers/fileHandlers.ts","../../electron/preload.ts"],"sourcesContent":["/**\r\n * File: electron/handlers/fileHandlers.ts\r\n * Description: Main process handlers for file operations\r\n */\r\n\r\nimport { ipcMain, dialog, shell } from \"electron\";\r\nimport fs from \"fs/promises\";\r\nimport path from \"path\";\r\nimport crypto from \"crypto\";\r\n\r\n// Define channel names as constants\r\nexport const FILE_CHANNELS = {\r\n  SELECT_FILE: \"file:select\",\r\n  READ_FILE: \"file:read\",\r\n  WRITE_FILE: \"file:write\",\r\n  GET_FILES: \"file:get-all\",\r\n  DELETE_FILE: \"file:delete\",\r\n  GET_FILE_INFO: \"file:info\",\r\n  RENAME_FILE: \"file:rename\",\r\n  CREATE_DIRECTORY: \"file:create-dir\",\r\n  MOVE_FILE: \"file:move\",\r\n  COPY_FILE: \"file:copy\",\r\n  WATCH_FILE: \"file:watch\",\r\n  GET_FILE_HASH: \"file:hash\",\r\n  OPEN_FILE: \"file:open\",\r\n} as const;\r\n\r\nexport function setupFileHandlers() {\r\n  // Handler for file selection dialog\r\n  ipcMain.handle(\r\n    FILE_CHANNELS.SELECT_FILE,\r\n    async (\r\n      _,\r\n      options?: {\r\n        multiple?: boolean;\r\n        directory?: boolean;\r\n        filters?: { name: string; extensions: string[] }[];\r\n      }\r\n    ) => {\r\n      try {\r\n        const properties: Array<\r\n          \"openFile\" | \"multiSelections\" | \"openDirectory\"\r\n        > = options?.directory ? [\"openDirectory\"] : [\"openFile\"];\r\n\r\n        if (options?.multiple && !options?.directory) {\r\n          properties.push(\"multiSelections\");\r\n        }\r\n\r\n        const result = await dialog.showOpenDialog({\r\n          properties,\r\n          filters: options?.filters,\r\n        });\r\n\r\n        return result.filePaths;\r\n      } catch (error) {\r\n        console.error(\"File selection error:\", error);\r\n        throw error;\r\n      }\r\n    }\r\n  );\r\n\r\n  // Handler for reading file contents\r\n  ipcMain.handle(FILE_CHANNELS.READ_FILE, async (_, filePath: string) => {\r\n    try {\r\n      const content = await fs.readFile(filePath);\r\n      const stats = await fs.stat(filePath);\r\n      const hash = await getFileHash(filePath);\r\n\r\n      return {\r\n        content,\r\n        name: path.basename(filePath),\r\n        path: filePath,\r\n        size: stats.size,\r\n        lastModified: stats.mtime,\r\n        hash,\r\n      };\r\n    } catch (error) {\r\n      console.error(\"File read error:\", error);\r\n      throw new Error(\r\n        `Failed to read file: ${\r\n          error instanceof Error ? error.message : \"Unknown error\"\r\n        }`\r\n      );\r\n    }\r\n  });\r\n\r\n  // Handler for writing files\r\n  ipcMain.handle(\r\n    FILE_CHANNELS.WRITE_FILE,\r\n    async (_, { filePath, content }: { filePath: string; content: Buffer }) => {\r\n      try {\r\n        const dir = path.dirname(filePath);\r\n        await fs.mkdir(dir, { recursive: true });\r\n        await fs.writeFile(filePath, content);\r\n        const stats = await fs.stat(filePath);\r\n        const hash = await getFileHash(filePath);\r\n\r\n        return {\r\n          name: path.basename(filePath),\r\n          path: filePath,\r\n          size: stats.size,\r\n          lastModified: stats.mtime,\r\n          hash,\r\n        };\r\n      } catch (error) {\r\n        console.error(\"File write error:\", error);\r\n        throw new Error(\r\n          `Failed to write file: ${\r\n            error instanceof Error ? error.message : \"Unknown error\"\r\n          }`\r\n        );\r\n      }\r\n    }\r\n  );\r\n\r\n  // Handler for getting all files in a directory\r\n  ipcMain.handle(FILE_CHANNELS.GET_FILES, async (_, dirPath: string) => {\r\n    try {\r\n      const entries = await fs.readdir(dirPath, { withFileTypes: true });\r\n\r\n      const files = await Promise.all(\r\n        entries.map(async (entry) => {\r\n          const filePath = path.join(dirPath, entry.name);\r\n          const stats = await fs.stat(filePath);\r\n          const hash = entry.isFile() ? await getFileHash(filePath) : null;\r\n\r\n          return {\r\n            name: entry.name,\r\n            path: filePath,\r\n            size: stats.size,\r\n            lastModified: stats.mtime,\r\n            type: entry.isDirectory() ? \"directory\" : getFileType(entry.name),\r\n            isDirectory: entry.isDirectory(),\r\n            hash,\r\n          };\r\n        })\r\n      );\r\n\r\n      return files;\r\n    } catch (error) {\r\n      console.error(\"Get files error:\", error);\r\n      throw new Error(\r\n        `Failed to get files: ${\r\n          error instanceof Error ? error.message : \"Unknown error\"\r\n        }`\r\n      );\r\n    }\r\n  });\r\n\r\n  // Handler for deleting files\r\n  ipcMain.handle(FILE_CHANNELS.DELETE_FILE, async (_, filePath: string) => {\r\n    try {\r\n      const stats = await fs.stat(filePath);\r\n      if (stats.isDirectory()) {\r\n        await fs.rm(filePath, { recursive: true });\r\n      } else {\r\n        await fs.unlink(filePath);\r\n      }\r\n      return true;\r\n    } catch (error) {\r\n      console.error(\"File deletion error:\", error);\r\n      throw new Error(\r\n        `Failed to delete file: ${\r\n          error instanceof Error ? error.message : \"Unknown error\"\r\n        }`\r\n      );\r\n    }\r\n  });\r\n\r\n  // Handler for getting file information\r\n  ipcMain.handle(FILE_CHANNELS.GET_FILE_INFO, async (_, filePath: string) => {\r\n    try {\r\n      const stats = await fs.stat(filePath);\r\n      const hash = stats.isFile() ? await getFileHash(filePath) : null;\r\n\r\n      return {\r\n        name: path.basename(filePath),\r\n        path: filePath,\r\n        size: stats.size,\r\n        lastModified: stats.mtime,\r\n        type: stats.isDirectory() ? \"directory\" : getFileType(filePath),\r\n        isDirectory: stats.isDirectory(),\r\n        hash,\r\n      };\r\n    } catch (error) {\r\n      console.error(\"Get file info error:\", error);\r\n      throw new Error(\r\n        `Failed to get file info: ${\r\n          error instanceof Error ? error.message : \"Unknown error\"\r\n        }`\r\n      );\r\n    }\r\n  });\r\n\r\n  // Handler for renaming files\r\n  ipcMain.handle(\r\n    FILE_CHANNELS.RENAME_FILE,\r\n    async (_, { oldPath, newPath }: { oldPath: string; newPath: string }) => {\r\n      try {\r\n        await fs.rename(oldPath, newPath);\r\n        const stats = await fs.stat(newPath);\r\n        const hash = stats.isFile() ? await getFileHash(newPath) : null;\r\n\r\n        return {\r\n          name: path.basename(newPath),\r\n          path: newPath,\r\n          size: stats.size,\r\n          lastModified: stats.mtime,\r\n          type: stats.isDirectory() ? \"directory\" : getFileType(newPath),\r\n          isDirectory: stats.isDirectory(),\r\n          hash,\r\n        };\r\n      } catch (error) {\r\n        console.error(\"File rename error:\", error);\r\n        throw new Error(\r\n          `Failed to rename file: ${\r\n            error instanceof Error ? error.message : \"Unknown error\"\r\n          }`\r\n        );\r\n      }\r\n    }\r\n  );\r\n\r\n  // Handler for creating directories\r\n  ipcMain.handle(FILE_CHANNELS.CREATE_DIRECTORY, async (_, dirPath: string) => {\r\n    try {\r\n      await fs.mkdir(dirPath, { recursive: true });\r\n      const stats = await fs.stat(dirPath);\r\n\r\n      return {\r\n        name: path.basename(dirPath),\r\n        path: dirPath,\r\n        size: stats.size,\r\n        lastModified: stats.mtime,\r\n        type: \"directory\",\r\n        isDirectory: true,\r\n        hash: null,\r\n      };\r\n    } catch (error) {\r\n      console.error(\"Directory creation error:\", error);\r\n      throw new Error(\r\n        `Failed to create directory: ${\r\n          error instanceof Error ? error.message : \"Unknown error\"\r\n        }`\r\n      );\r\n    }\r\n  });\r\n\r\n  // Handler for moving files\r\n  ipcMain.handle(\r\n    FILE_CHANNELS.MOVE_FILE,\r\n    async (\r\n      _,\r\n      { sourcePath, targetPath }: { sourcePath: string; targetPath: string }\r\n    ) => {\r\n      try {\r\n        await fs.rename(sourcePath, targetPath);\r\n        const stats = await fs.stat(targetPath);\r\n        const hash = stats.isFile() ? await getFileHash(targetPath) : null;\r\n\r\n        return {\r\n          name: path.basename(targetPath),\r\n          path: targetPath,\r\n          size: stats.size,\r\n          lastModified: stats.mtime,\r\n          type: stats.isDirectory() ? \"directory\" : getFileType(targetPath),\r\n          isDirectory: stats.isDirectory(),\r\n          hash,\r\n        };\r\n      } catch (error) {\r\n        console.error(\"File move error:\", error);\r\n        throw new Error(\r\n          `Failed to move file: ${\r\n            error instanceof Error ? error.message : \"Unknown error\"\r\n          }`\r\n        );\r\n      }\r\n    }\r\n  );\r\n\r\n  // Handler for copying files\r\n  ipcMain.handle(\r\n    FILE_CHANNELS.COPY_FILE,\r\n    async (\r\n      _,\r\n      { sourcePath, targetPath }: { sourcePath: string; targetPath: string }\r\n    ) => {\r\n      try {\r\n        await fs.copyFile(sourcePath, targetPath);\r\n        const stats = await fs.stat(targetPath);\r\n        const hash = await getFileHash(targetPath);\r\n\r\n        return {\r\n          name: path.basename(targetPath),\r\n          path: targetPath,\r\n          size: stats.size,\r\n          lastModified: stats.mtime,\r\n          type: getFileType(targetPath),\r\n          isDirectory: false,\r\n          hash,\r\n        };\r\n      } catch (error) {\r\n        console.error(\"File copy error:\", error);\r\n        throw new Error(\r\n          `Failed to copy file: ${\r\n            error instanceof Error ? error.message : \"Unknown error\"\r\n          }`\r\n        );\r\n      }\r\n    }\r\n  );\r\n\r\n  // Handler for opening files in default application\r\n  ipcMain.handle(FILE_CHANNELS.OPEN_FILE, async (_, filePath: string) => {\r\n    try {\r\n      await shell.openPath(filePath);\r\n      return true;\r\n    } catch (error) {\r\n      console.error(\"File open error:\", error);\r\n      throw new Error(\r\n        `Failed to open file: ${\r\n          error instanceof Error ? error.message : \"Unknown error\"\r\n        }`\r\n      );\r\n    }\r\n  });\r\n}\r\n\r\n// Helper function to get file type from extension\r\nfunction getFileType(filename: string): string {\r\n  const ext = path.extname(filename).toLowerCase();\r\n  switch (ext) {\r\n    case \".pdf\":\r\n      return \"pdf\";\r\n    case \".xlsx\":\r\n    case \".xls\":\r\n      return \"excel\";\r\n    case \".doc\":\r\n    case \".docx\":\r\n      return \"word\";\r\n    case \".txt\":\r\n    case \".md\":\r\n      return \"text\";\r\n    default:\r\n      return \"other\";\r\n  }\r\n}\r\n\r\n// Helper function to calculate file hash\r\nasync function getFileHash(filePath: string): Promise<string> {\r\n  try {\r\n    const content = await fs.readFile(filePath);\r\n    return crypto.createHash(\"sha256\").update(content).digest(\"hex\");\r\n  } catch (error) {\r\n    console.error(\"Hash calculation error:\", error);\r\n    throw new Error(\r\n      `Failed to calculate file hash: ${\r\n        error instanceof Error ? error.message : \"Unknown error\"\r\n      }`\r\n    );\r\n  }\r\n}\r\n","import { contextBridge, ipcRenderer } from \"electron\";\r\nimport { FILE_CHANNELS } from \"./handlers/fileHandlers\";\r\n\r\n// Define valid channel types\r\ntype ValidChannels = \"main-process-message\" | keyof typeof FILE_CHANNELS;\r\n\r\n// Define IPC message types\r\ntype IpcMessage = {\r\n  type: string;\r\n  payload?: unknown;\r\n};\r\n\r\n// ✅ Expose Electron API for IPC communication\r\ncontextBridge.exposeInMainWorld(\"electronAPI\", {\r\n  ipcRenderer: {\r\n    on: (channel: ValidChannels, func: (data: unknown) => void) => {\r\n      const subscription = (_: unknown, ...args: unknown[]) => func(args[0]); // Fix TypeScript spread issue\r\n      ipcRenderer.on(channel, subscription);\r\n      return () => ipcRenderer.removeListener(channel, subscription);\r\n    },\r\n    once: (channel: ValidChannels, func: (data: unknown) => void) => {\r\n      ipcRenderer.once(channel, (_: unknown, ...args: unknown[]) =>\r\n        func(args[0])\r\n      ); // Fix TypeScript spread issue\r\n    },\r\n    send: (channel: ValidChannels, message: IpcMessage) => {\r\n      ipcRenderer.send(channel, message);\r\n    },\r\n    invoke: async (\r\n      channel: ValidChannels,\r\n      message?: IpcMessage\r\n    ): Promise<unknown> => {\r\n      return await ipcRenderer.invoke(channel, message);\r\n    },\r\n  },\r\n\r\n  // ✅ Expose an async function to get the PDF path\r\n  getPDFPath: async (): Promise<string> => {\r\n    try {\r\n      return await ipcRenderer.invoke(\"get-pdf-path\");\r\n    } catch (error) {\r\n      console.error(\"❌ Error retrieving PDF path:\", error);\r\n      return \"\";\r\n    }\r\n  },\r\n});\r\n\r\n// ✅ Define the file API with correct typings and error handling\r\nconst fileAPI = {\r\n  selectFile: async (options?: { multiple?: boolean }): Promise<unknown> => {\r\n    try {\r\n      return await ipcRenderer.invoke(FILE_CHANNELS.SELECT_FILE, options);\r\n    } catch (error) {\r\n      console.error(\"❌ Error selecting file:\", error);\r\n    }\r\n  },\r\n\r\n  readFile: async (path: string): Promise<unknown> => {\r\n    try {\r\n      return await ipcRenderer.invoke(FILE_CHANNELS.READ_FILE, path);\r\n    } catch (error) {\r\n      console.error(`❌ Error reading file at ${path}:`, error);\r\n    }\r\n  },\r\n\r\n  writeFile: async (options: {\r\n    filePath: string;\r\n    content: Buffer;\r\n  }): Promise<unknown> => {\r\n    try {\r\n      return await ipcRenderer.invoke(FILE_CHANNELS.WRITE_FILE, options);\r\n    } catch (error) {\r\n      console.error(`❌ Error writing to file ${options.filePath}:`, error);\r\n    }\r\n  },\r\n\r\n  getFiles: async (dirPath: string): Promise<unknown> => {\r\n    try {\r\n      return await ipcRenderer.invoke(FILE_CHANNELS.GET_FILES, dirPath);\r\n    } catch (error) {\r\n      console.error(`❌ Error getting files from ${dirPath}:`, error);\r\n    }\r\n  },\r\n\r\n  deleteFile: async (path: string): Promise<unknown> => {\r\n    try {\r\n      return await ipcRenderer.invoke(FILE_CHANNELS.DELETE_FILE, path);\r\n    } catch (error) {\r\n      console.error(`❌ Error deleting file at ${path}:`, error);\r\n    }\r\n  },\r\n\r\n  getFileInfo: async (path: string): Promise<unknown> => {\r\n    try {\r\n      return await ipcRenderer.invoke(FILE_CHANNELS.GET_FILE_INFO, path);\r\n    } catch (error) {\r\n      console.error(`❌ Error getting file info for ${path}:`, error);\r\n    }\r\n  },\r\n\r\n  renameFile: async (oldPath: string, newPath: string): Promise<unknown> => {\r\n    try {\r\n      return await ipcRenderer.invoke(FILE_CHANNELS.RENAME_FILE, {\r\n        oldPath,\r\n        newPath,\r\n      });\r\n    } catch (error) {\r\n      console.error(\r\n        `❌ Error renaming file from ${oldPath} to ${newPath}:`,\r\n        error\r\n      );\r\n    }\r\n  },\r\n\r\n  createDirectory: async (path: string): Promise<unknown> => {\r\n    try {\r\n      return await ipcRenderer.invoke(FILE_CHANNELS.CREATE_DIRECTORY, path);\r\n    } catch (error) {\r\n      console.error(`❌ Error creating directory at ${path}:`, error);\r\n    }\r\n  },\r\n\r\n  moveFile: async (options: {\r\n    sourcePath: string;\r\n    targetPath: string;\r\n  }): Promise<unknown> => {\r\n    try {\r\n      return await ipcRenderer.invoke(FILE_CHANNELS.MOVE_FILE, options);\r\n    } catch (error) {\r\n      console.error(\r\n        `❌ Error moving file from ${options.sourcePath} to ${options.targetPath}:`,\r\n        error\r\n      );\r\n    }\r\n  },\r\n\r\n  copyFile: async (options: {\r\n    sourcePath: string;\r\n    targetPath: string;\r\n  }): Promise<unknown> => {\r\n    try {\r\n      return await ipcRenderer.invoke(FILE_CHANNELS.COPY_FILE, options);\r\n    } catch (error) {\r\n      console.error(\r\n        `❌ Error copying file from ${options.sourcePath} to ${options.targetPath}:`,\r\n        error\r\n      );\r\n    }\r\n  },\r\n\r\n  openFile: async (filePath: string): Promise<unknown> => {\r\n    try {\r\n      return await ipcRenderer.invoke(FILE_CHANNELS.OPEN_FILE, filePath);\r\n    } catch (error) {\r\n      console.error(`❌ Error opening file ${filePath}:`, error);\r\n    }\r\n  },\r\n};\r\n\r\n// ✅ Expose fileAPI to the renderer process\r\ncontextBridge.exposeInMainWorld(\"fileAPI\", fileAPI);\r\n\r\n// Declare the fileAPI type for TypeScript\r\nexport type FileAPI = typeof fileAPI;\r\n"],"names":["contextBridge","ipcRenderer"],"mappings":"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"}