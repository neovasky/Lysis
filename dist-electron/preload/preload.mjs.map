{"version":3,"file":"preload.mjs","sources":["../../electron/handlers/fileHandlers.ts","../../electron/preload.ts"],"sourcesContent":["/**\r\n * File: electron/handlers/fileHandlers.ts\r\n * Description: Main process handlers for file operations\r\n */\r\n\r\nimport { ipcMain, dialog } from \"electron\";\r\nimport fs from \"fs/promises\";\r\nimport path from \"path\";\r\nimport crypto from \"crypto\";\r\n\r\n// Define channel names as constants\r\nexport const FILE_CHANNELS = {\r\n  SELECT_FILE: \"file:select\",\r\n  READ_FILE: \"file:read\",\r\n  WRITE_FILE: \"file:write\",\r\n  GET_FILES: \"file:get-all\",\r\n  DELETE_FILE: \"file:delete\",\r\n  GET_FILE_INFO: \"file:info\",\r\n  RENAME_FILE: \"file:rename\",\r\n  CREATE_DIRECTORY: \"file:create-dir\",\r\n  MOVE_FILE: \"file:move\",\r\n  COPY_FILE: \"file:copy\",\r\n  WATCH_FILE: \"file:watch\",\r\n  GET_FILE_HASH: \"file:hash\",\r\n} as const;\r\n\r\nexport function setupFileHandlers() {\r\n  // Handler for file selection dialog\r\n  ipcMain.handle(\r\n    FILE_CHANNELS.SELECT_FILE,\r\n    async (\r\n      _,\r\n      options?: {\r\n        multiple?: boolean;\r\n        directory?: boolean;\r\n        filters?: { name: string; extensions: string[] }[];\r\n      }\r\n    ) => {\r\n      try {\r\n        const properties: Array<\r\n          \"openFile\" | \"multiSelections\" | \"openDirectory\"\r\n        > = options?.directory ? [\"openDirectory\"] : [\"openFile\"];\r\n\r\n        if (options?.multiple && !options?.directory) {\r\n          properties.push(\"multiSelections\");\r\n        }\r\n\r\n        const result = await dialog.showOpenDialog({\r\n          properties,\r\n          filters: options?.filters,\r\n        });\r\n\r\n        return result.filePaths;\r\n      } catch (error) {\r\n        console.error(\"File selection error:\", error);\r\n        throw error;\r\n      }\r\n    }\r\n  );\r\n\r\n  // Handler for reading file contents\r\n  ipcMain.handle(FILE_CHANNELS.READ_FILE, async (_, filePath: string) => {\r\n    try {\r\n      const content = await fs.readFile(filePath);\r\n      const stats = await fs.stat(filePath);\r\n      const hash = await getFileHash(filePath);\r\n\r\n      return {\r\n        content,\r\n        name: path.basename(filePath),\r\n        path: filePath,\r\n        size: stats.size,\r\n        lastModified: stats.mtime,\r\n        hash,\r\n      };\r\n    } catch (error) {\r\n      console.error(\"File read error:\", error);\r\n      throw new Error(\r\n        `Failed to read file: ${\r\n          error instanceof Error ? error.message : \"Unknown error\"\r\n        }`\r\n      );\r\n    }\r\n  });\r\n\r\n  // Handler for writing files\r\n  ipcMain.handle(\r\n    FILE_CHANNELS.WRITE_FILE,\r\n    async (_, { filePath, content, createDirectory }) => {\r\n      try {\r\n        if (createDirectory) {\r\n          await fs.mkdir(path.dirname(filePath), { recursive: true });\r\n        }\r\n\r\n        await fs.writeFile(filePath, content);\r\n        const stats = await fs.stat(filePath);\r\n        const hash = await getFileHash(filePath);\r\n\r\n        return {\r\n          name: path.basename(filePath),\r\n          path: filePath,\r\n          size: stats.size,\r\n          lastModified: stats.mtime,\r\n          hash,\r\n        };\r\n      } catch (error) {\r\n        console.error(\"File write error:\", error);\r\n        throw new Error(\r\n          `Failed to write file: ${\r\n            error instanceof Error ? error.message : \"Unknown error\"\r\n          }`\r\n        );\r\n      }\r\n    }\r\n  );\r\n\r\n  // Handler for getting all files in a directory\r\n  ipcMain.handle(FILE_CHANNELS.GET_FILES, async (_, dirPath: string) => {\r\n    try {\r\n      const entries = await fs.readdir(dirPath, { withFileTypes: true });\r\n\r\n      const files = await Promise.all(\r\n        entries.map(async (entry) => {\r\n          const filePath = path.join(dirPath, entry.name);\r\n          const stats = await fs.stat(filePath);\r\n          const hash = entry.isFile() ? await getFileHash(filePath) : null;\r\n\r\n          return {\r\n            name: entry.name,\r\n            path: filePath,\r\n            size: stats.size,\r\n            lastModified: stats.mtime,\r\n            type: entry.isDirectory() ? \"directory\" : getFileType(entry.name),\r\n            isDirectory: entry.isDirectory(),\r\n            hash,\r\n          };\r\n        })\r\n      );\r\n\r\n      return files;\r\n    } catch (error) {\r\n      console.error(\"Get files error:\", error);\r\n      throw new Error(\r\n        `Failed to get files: ${\r\n          error instanceof Error ? error.message : \"Unknown error\"\r\n        }`\r\n      );\r\n    }\r\n  });\r\n\r\n  // Handler for deleting files\r\n  ipcMain.handle(FILE_CHANNELS.DELETE_FILE, async (_, filePath: string) => {\r\n    try {\r\n      const stats = await fs.stat(filePath);\r\n      if (stats.isDirectory()) {\r\n        await fs.rm(filePath, { recursive: true });\r\n      } else {\r\n        await fs.unlink(filePath);\r\n      }\r\n      return true;\r\n    } catch (error) {\r\n      console.error(\"File deletion error:\", error);\r\n      throw new Error(\r\n        `Failed to delete file: ${\r\n          error instanceof Error ? error.message : \"Unknown error\"\r\n        }`\r\n      );\r\n    }\r\n  });\r\n\r\n  // Handler for getting file information\r\n  ipcMain.handle(FILE_CHANNELS.GET_FILE_INFO, async (_, filePath: string) => {\r\n    try {\r\n      const stats = await fs.stat(filePath);\r\n      const hash = stats.isFile() ? await getFileHash(filePath) : null;\r\n\r\n      return {\r\n        name: path.basename(filePath),\r\n        path: filePath,\r\n        size: stats.size,\r\n        lastModified: stats.mtime,\r\n        type: stats.isDirectory() ? \"directory\" : getFileType(filePath),\r\n        isDirectory: stats.isDirectory(),\r\n        hash,\r\n      };\r\n    } catch (error) {\r\n      console.error(\"Get file info error:\", error);\r\n      throw new Error(\r\n        `Failed to get file info: ${\r\n          error instanceof Error ? error.message : \"Unknown error\"\r\n        }`\r\n      );\r\n    }\r\n  });\r\n\r\n  // Handler for renaming files\r\n  ipcMain.handle(FILE_CHANNELS.RENAME_FILE, async (_, { oldPath, newPath }) => {\r\n    try {\r\n      await fs.rename(oldPath, newPath);\r\n      const stats = await fs.stat(newPath);\r\n      const hash = stats.isFile() ? await getFileHash(newPath) : null;\r\n\r\n      return {\r\n        name: path.basename(newPath),\r\n        path: newPath,\r\n        size: stats.size,\r\n        lastModified: stats.mtime,\r\n        type: stats.isDirectory() ? \"directory\" : getFileType(newPath),\r\n        isDirectory: stats.isDirectory(),\r\n        hash,\r\n      };\r\n    } catch (error) {\r\n      console.error(\"File rename error:\", error);\r\n      throw new Error(\r\n        `Failed to rename file: ${\r\n          error instanceof Error ? error.message : \"Unknown error\"\r\n        }`\r\n      );\r\n    }\r\n  });\r\n\r\n  // Handler for creating directories\r\n  ipcMain.handle(FILE_CHANNELS.CREATE_DIRECTORY, async (_, dirPath: string) => {\r\n    try {\r\n      await fs.mkdir(dirPath, { recursive: true });\r\n      const stats = await fs.stat(dirPath);\r\n\r\n      return {\r\n        name: path.basename(dirPath),\r\n        path: dirPath,\r\n        size: stats.size,\r\n        lastModified: stats.mtime,\r\n        type: \"directory\",\r\n        isDirectory: true,\r\n        hash: null,\r\n      };\r\n    } catch (error) {\r\n      console.error(\"Directory creation error:\", error);\r\n      throw new Error(\r\n        `Failed to create directory: ${\r\n          error instanceof Error ? error.message : \"Unknown error\"\r\n        }`\r\n      );\r\n    }\r\n  });\r\n\r\n  // Handler for moving files\r\n  ipcMain.handle(\r\n    FILE_CHANNELS.MOVE_FILE,\r\n    async (_, { sourcePath, targetPath }) => {\r\n      try {\r\n        await fs.rename(sourcePath, targetPath);\r\n        const stats = await fs.stat(targetPath);\r\n        const hash = stats.isFile() ? await getFileHash(targetPath) : null;\r\n\r\n        return {\r\n          name: path.basename(targetPath),\r\n          path: targetPath,\r\n          size: stats.size,\r\n          lastModified: stats.mtime,\r\n          type: stats.isDirectory() ? \"directory\" : getFileType(targetPath),\r\n          isDirectory: stats.isDirectory(),\r\n          hash,\r\n        };\r\n      } catch (error) {\r\n        console.error(\"File move error:\", error);\r\n        throw new Error(\r\n          `Failed to move file: ${\r\n            error instanceof Error ? error.message : \"Unknown error\"\r\n          }`\r\n        );\r\n      }\r\n    }\r\n  );\r\n\r\n  // Handler for copying files\r\n  ipcMain.handle(\r\n    FILE_CHANNELS.COPY_FILE,\r\n    async (_, { sourcePath, targetPath }) => {\r\n      try {\r\n        await fs.copyFile(sourcePath, targetPath);\r\n        const stats = await fs.stat(targetPath);\r\n        const hash = await getFileHash(targetPath);\r\n\r\n        return {\r\n          name: path.basename(targetPath),\r\n          path: targetPath,\r\n          size: stats.size,\r\n          lastModified: stats.mtime,\r\n          type: getFileType(targetPath),\r\n          isDirectory: false,\r\n          hash,\r\n        };\r\n      } catch (error) {\r\n        console.error(\"File copy error:\", error);\r\n        throw new Error(\r\n          `Failed to copy file: ${\r\n            error instanceof Error ? error.message : \"Unknown error\"\r\n          }`\r\n        );\r\n      }\r\n    }\r\n  );\r\n\r\n  // Helper function to get file type from extension\r\n  function getFileType(filename: string): string {\r\n    const ext = path.extname(filename).toLowerCase();\r\n    switch (ext) {\r\n      case \".pdf\":\r\n        return \"pdf\";\r\n      case \".xlsx\":\r\n      case \".xls\":\r\n        return \"excel\";\r\n      case \".doc\":\r\n      case \".docx\":\r\n        return \"word\";\r\n      case \".txt\":\r\n      case \".md\":\r\n        return \"text\";\r\n      default:\r\n        return \"other\";\r\n    }\r\n  }\r\n\r\n  // Helper function to calculate file hash\r\n  async function getFileHash(filePath: string): Promise<string> {\r\n    try {\r\n      const content = await fs.readFile(filePath);\r\n      return crypto.createHash(\"sha256\").update(content).digest(\"hex\");\r\n    } catch (error) {\r\n      console.error(\"Hash calculation error:\", error);\r\n      throw new Error(\r\n        `Failed to calculate file hash: ${\r\n          error instanceof Error ? error.message : \"Unknown error\"\r\n        }`\r\n      );\r\n    }\r\n  }\r\n}\r\n","// File: electron/preload.ts\r\nimport { contextBridge, ipcRenderer, IpcRendererEvent } from \"electron\";\r\nimport { FILE_CHANNELS } from \"./handlers/fileHandlers\";\r\nimport type { FileAPI } from \"../src/types/window\";\r\n\r\n// Define valid channel types\r\ntype ValidChannels = \"main-process-message\" | keyof typeof FILE_CHANNELS;\r\n\r\n// Define IPC message types\r\ntype IpcMessage = {\r\n  type: string;\r\n  payload?: unknown;\r\n};\r\n\r\n// Expose protected IPC methods to renderer\r\ncontextBridge.exposeInMainWorld(\"electron\", {\r\n  ipcRenderer: {\r\n    on: (channel: ValidChannels, func: (data: unknown) => void) => {\r\n      const subscription = (_event: IpcRendererEvent, ...args: unknown[]) =>\r\n        func(args);\r\n      ipcRenderer.on(channel, subscription);\r\n      return () => ipcRenderer.removeListener(channel, subscription);\r\n    },\r\n    once: (channel: ValidChannels, func: (data: unknown) => void) => {\r\n      ipcRenderer.once(\r\n        channel,\r\n        (_event: IpcRendererEvent, ...args: unknown[]) => func(args)\r\n      );\r\n    },\r\n    send: (channel: ValidChannels, message: IpcMessage) => {\r\n      ipcRenderer.send(channel, message);\r\n    },\r\n  },\r\n});\r\n\r\n// Expose the file API to the renderer process\r\ncontextBridge.exposeInMainWorld(\"fileAPI\", {\r\n  selectFile: (options?: { multiple?: boolean }) =>\r\n    ipcRenderer.invoke(FILE_CHANNELS.SELECT_FILE, options),\r\n\r\n  readFile: (path: string) => ipcRenderer.invoke(FILE_CHANNELS.READ_FILE, path),\r\n\r\n  writeFile: (options: { filePath: string; content: Buffer }) =>\r\n    ipcRenderer.invoke(FILE_CHANNELS.WRITE_FILE, options),\r\n\r\n  getFiles: (dirPath: string) =>\r\n    ipcRenderer.invoke(FILE_CHANNELS.GET_FILES, dirPath),\r\n\r\n  deleteFile: (path: string) =>\r\n    ipcRenderer.invoke(FILE_CHANNELS.DELETE_FILE, path),\r\n\r\n  getFileInfo: (path: string) =>\r\n    ipcRenderer.invoke(FILE_CHANNELS.GET_FILE_INFO, path),\r\n\r\n  renameFile: (oldPath: string, newPath: string) =>\r\n    ipcRenderer.invoke(FILE_CHANNELS.RENAME_FILE, { oldPath, newPath }),\r\n\r\n  createDirectory: (path: string) =>\r\n    ipcRenderer.invoke(FILE_CHANNELS.CREATE_DIRECTORY, path),\r\n\r\n  moveFile: (options: { sourcePath: string; targetPath: string }) =>\r\n    ipcRenderer.invoke(FILE_CHANNELS.MOVE_FILE, options),\r\n\r\n  copyFile: (options: { sourcePath: string; targetPath: string }) =>\r\n    ipcRenderer.invoke(FILE_CHANNELS.COPY_FILE, options),\r\n} as FileAPI);\r\n"],"names":["contextBridge","ipcRenderer"],"mappings":";;;;;AAWO,MAAM,gBAAgB;AAAA,EAC3B,aAAa;AAAA,EACb,WAAW;AAAA,EACX,YAAY;AAAA,EACZ,WAAW;AAAA,EACX,aAAa;AAAA,EACb,eAAe;AAAA,EACf,aAAa;AAAA,EACb,kBAAkB;AAAA,EAClB,WAAW;AAAA,EACX,WAAW;AAGb;ACTAA,SAAAA,cAAc,kBAAkB,YAAY;AAAA,EAC1C,aAAa;AAAA,IACX,IAAI,CAAC,SAAwB,SAAkC;AAC7D,YAAM,eAAe,CAAC,WAA6B,SACjD,KAAK,IAAI;AACCC,2BAAA,GAAG,SAAS,YAAY;AACpC,aAAO,MAAMA,SAAA,YAAY,eAAe,SAAS,YAAY;AAAA,IAC/D;AAAA,IACA,MAAM,CAAC,SAAwB,SAAkC;AACnDA,eAAAA,YAAA;AAAA,QACV;AAAA,QACA,CAAC,WAA6B,SAAoB,KAAK,IAAI;AAAA,MAC7D;AAAA,IACF;AAAA,IACA,MAAM,CAAC,SAAwB,YAAwB;AACzCA,2BAAA,KAAK,SAAS,OAAO;AAAA,IAAA;AAAA,EACnC;AAEJ,CAAC;AAGDD,SAAAA,cAAc,kBAAkB,WAAW;AAAA,EACzC,YAAY,CAAC,YACXC,qBAAY,OAAO,cAAc,aAAa,OAAO;AAAA,EAEvD,UAAU,CAAC,SAAiBA,qBAAY,OAAO,cAAc,WAAW,IAAI;AAAA,EAE5E,WAAW,CAAC,YACVA,qBAAY,OAAO,cAAc,YAAY,OAAO;AAAA,EAEtD,UAAU,CAAC,YACTA,qBAAY,OAAO,cAAc,WAAW,OAAO;AAAA,EAErD,YAAY,CAAC,SACXA,qBAAY,OAAO,cAAc,aAAa,IAAI;AAAA,EAEpD,aAAa,CAAC,SACZA,qBAAY,OAAO,cAAc,eAAe,IAAI;AAAA,EAEtD,YAAY,CAAC,SAAiB,YAC5BA,qBAAY,OAAO,cAAc,aAAa,EAAE,SAAS,SAAS;AAAA,EAEpE,iBAAiB,CAAC,SAChBA,qBAAY,OAAO,cAAc,kBAAkB,IAAI;AAAA,EAEzD,UAAU,CAAC,YACTA,qBAAY,OAAO,cAAc,WAAW,OAAO;AAAA,EAErD,UAAU,CAAC,YACTA,SAAAA,YAAY,OAAO,cAAc,WAAW,OAAO;AACvD,CAAY;"}