{"version":3,"file":"preload.mjs","sources":["../../electron/handlers/fileHandlers.ts","../../electron/preload.ts"],"sourcesContent":["/**\r\n * File: electron/handlers/fileHandlers.ts\r\n * Description: Main process handlers for file operations\r\n */\r\n\r\nimport { ipcMain, dialog } from \"electron\";\r\nimport fs from \"fs/promises\";\r\nimport path from \"path\";\r\n\r\n// Define channel names as constants\r\nexport const FILE_CHANNELS = {\r\n  SELECT_FILE: \"file:select\",\r\n  READ_FILE: \"file:read\",\r\n  WRITE_FILE: \"file:write\",\r\n  GET_FILES: \"file:get-all\",\r\n  DELETE_FILE: \"file:delete\",\r\n  GET_FILE_INFO: \"file:info\",\r\n} as const;\r\n\r\nexport function setupFileHandlers() {\r\n  // Handler for file selection dialog\r\n  ipcMain.handle(\r\n    FILE_CHANNELS.SELECT_FILE,\r\n    async (_, options?: { multiple?: boolean }) => {\r\n      const result = await dialog.showOpenDialog({\r\n        properties: options?.multiple\r\n          ? [\"openFile\", \"multiSelections\"]\r\n          : [\"openFile\"],\r\n      });\r\n\r\n      return result.filePaths;\r\n    }\r\n  );\r\n\r\n  // Handler for reading file contents\r\n  ipcMain.handle(FILE_CHANNELS.READ_FILE, async (_, filePath: string) => {\r\n    try {\r\n      const content = await fs.readFile(filePath);\r\n      const stats = await fs.stat(filePath);\r\n\r\n      return {\r\n        content,\r\n        name: path.basename(filePath),\r\n        path: filePath,\r\n        size: stats.size,\r\n        lastModified: stats.mtime,\r\n      };\r\n    } catch (error: unknown) {\r\n      const message =\r\n        error instanceof Error ? error.message : \"Unknown error occurred\";\r\n      throw new Error(`Failed to read file: ${message}`);\r\n    }\r\n  });\r\n\r\n  // Handler for writing files\r\n  ipcMain.handle(FILE_CHANNELS.WRITE_FILE, async (_, { filePath, content }) => {\r\n    try {\r\n      await fs.writeFile(filePath, content);\r\n      const stats = await fs.stat(filePath);\r\n\r\n      return {\r\n        name: path.basename(filePath),\r\n        path: filePath,\r\n        size: stats.size,\r\n        lastModified: stats.mtime,\r\n      };\r\n    } catch (error: unknown) {\r\n      const message =\r\n        error instanceof Error ? error.message : \"Unknown error occurred\";\r\n      throw new Error(`Failed to write file: ${message}`);\r\n    }\r\n  });\r\n\r\n  // Handler for getting all files in a directory\r\n  ipcMain.handle(FILE_CHANNELS.GET_FILES, async (_, dirPath: string) => {\r\n    try {\r\n      const entries = await fs.readdir(dirPath, { withFileTypes: true });\r\n\r\n      const files = await Promise.all(\r\n        entries\r\n          .filter((entry) => entry.isFile())\r\n          .map(async (entry) => {\r\n            const filePath = path.join(dirPath, entry.name);\r\n            const stats = await fs.stat(filePath);\r\n\r\n            return {\r\n              name: entry.name,\r\n              path: filePath,\r\n              size: stats.size,\r\n              lastModified: stats.mtime,\r\n              type:\r\n                path.extname(entry.name).toLowerCase().slice(1) || \"unknown\",\r\n            };\r\n          })\r\n      );\r\n\r\n      return files;\r\n    } catch (error: unknown) {\r\n      const message =\r\n        error instanceof Error ? error.message : \"Unknown error occurred\";\r\n      throw new Error(`Failed to get files: ${message}`);\r\n    }\r\n  });\r\n\r\n  // Handler for deleting files\r\n  ipcMain.handle(FILE_CHANNELS.DELETE_FILE, async (_, filePath: string) => {\r\n    try {\r\n      await fs.unlink(filePath);\r\n      return true;\r\n    } catch (error: unknown) {\r\n      const message =\r\n        error instanceof Error ? error.message : \"Unknown error occurred\";\r\n      throw new Error(`Failed to delete file: ${message}`);\r\n    }\r\n  });\r\n\r\n  // Handler for getting file information\r\n  ipcMain.handle(FILE_CHANNELS.GET_FILE_INFO, async (_, filePath: string) => {\r\n    try {\r\n      const stats = await fs.stat(filePath);\r\n\r\n      return {\r\n        name: path.basename(filePath),\r\n        path: filePath,\r\n        size: stats.size,\r\n        lastModified: stats.mtime,\r\n        type: path.extname(filePath).toLowerCase().slice(1) || \"unknown\",\r\n      };\r\n    } catch (error: unknown) {\r\n      const message =\r\n        error instanceof Error ? error.message : \"Unknown error occurred\";\r\n      throw new Error(`Failed to get file info: ${message}`);\r\n    }\r\n  });\r\n}\r\n","/**\r\n * File: electron/preload.ts\r\n * Description: Preload script to expose APIs to renderer process\r\n */\r\n\r\nimport { contextBridge, ipcRenderer } from \"electron\";\r\nimport { FILE_CHANNELS } from \"./handlers/fileHandlers\";\r\n\r\n// Define the API type\r\nexport interface FileAPI {\r\n  selectFile: (options?: { multiple?: boolean }) => Promise<string[]>;\r\n  readFile: (path: string) => Promise<{\r\n    content: Buffer;\r\n    name: string;\r\n    path: string;\r\n    size: number;\r\n    lastModified: Date;\r\n  }>;\r\n  writeFile: (options: { filePath: string; content: Buffer }) => Promise<{\r\n    name: string;\r\n    path: string;\r\n    size: number;\r\n    lastModified: Date;\r\n  }>;\r\n  getFiles: (dirPath: string) => Promise<\r\n    Array<{\r\n      name: string;\r\n      path: string;\r\n      size: number;\r\n      lastModified: Date;\r\n      type: string;\r\n    }>\r\n  >;\r\n  deleteFile: (path: string) => Promise<boolean>;\r\n  getFileInfo: (path: string) => Promise<{\r\n    name: string;\r\n    path: string;\r\n    size: number;\r\n    lastModified: Date;\r\n    type: string;\r\n  }>;\r\n}\r\n\r\n// Expose the file API to the renderer process\r\ncontextBridge.exposeInMainWorld(\"fileAPI\", {\r\n  selectFile: (options?: { multiple?: boolean }) =>\r\n    ipcRenderer.invoke(FILE_CHANNELS.SELECT_FILE, options),\r\n\r\n  readFile: (path: string) => ipcRenderer.invoke(FILE_CHANNELS.READ_FILE, path),\r\n\r\n  writeFile: (options: { filePath: string; content: Buffer }) =>\r\n    ipcRenderer.invoke(FILE_CHANNELS.WRITE_FILE, options),\r\n\r\n  getFiles: (dirPath: string) =>\r\n    ipcRenderer.invoke(FILE_CHANNELS.GET_FILES, dirPath),\r\n\r\n  deleteFile: (path: string) =>\r\n    ipcRenderer.invoke(FILE_CHANNELS.DELETE_FILE, path),\r\n\r\n  getFileInfo: (path: string) =>\r\n    ipcRenderer.invoke(FILE_CHANNELS.GET_FILE_INFO, path),\r\n} as FileAPI);\r\n\r\n// Add the API type to the window object\r\ndeclare global {\r\n  interface Window {\r\n    fileAPI: FileAPI;\r\n  }\r\n}\r\n"],"names":["contextBridge","ipcRenderer"],"mappings":";;;;AAUO,MAAM,gBAAgB;AAAA,EAC3B,aAAa;AAAA,EACb,WAAW;AAAA,EACX,YAAY;AAAA,EACZ,WAAW;AAAA,EACX,aAAa;AAAA,EACb,eAAe;AACjB;AC2BAA,SAAAA,cAAc,kBAAkB,WAAW;AAAA,EACzC,YAAY,CAAC,YACXC,qBAAY,OAAO,cAAc,aAAa,OAAO;AAAA,EAEvD,UAAU,CAAC,SAAiBA,qBAAY,OAAO,cAAc,WAAW,IAAI;AAAA,EAE5E,WAAW,CAAC,YACVA,qBAAY,OAAO,cAAc,YAAY,OAAO;AAAA,EAEtD,UAAU,CAAC,YACTA,qBAAY,OAAO,cAAc,WAAW,OAAO;AAAA,EAErD,YAAY,CAAC,SACXA,qBAAY,OAAO,cAAc,aAAa,IAAI;AAAA,EAEpD,aAAa,CAAC,SACZA,SAAAA,YAAY,OAAO,cAAc,eAAe,IAAI;AACxD,CAAY;"}